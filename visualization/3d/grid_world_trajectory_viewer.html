<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid World Trajectory Viewer - Meta-Learning SNN</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 107, 0, 0.3);
            font-size: 14px;
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 107, 0, 0.3);
            font-size: 14px;
            width: 300px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #controls button {
            display: block;
            margin: 5px 0;
            padding: 8px 15px;
            background: #FF6B00;  /* Aperture orange */
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            width: 100%;
        }
        
        #controls button:hover {
            background: #E85A00;  /* Darker orange */
        }
        
        #controls button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #controls input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .label {
            font-size: 12px;
            color: #aaa;
        }
        
        h3 {
            margin-top: 0;
            color: #FF6B00;
        }
        
        #loadingOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            z-index: 1000;
        }
        
        .play-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        
        .play-controls button {
            flex: 1;
            margin: 0 !important;
        }
        
        #timelineContainer {
            margin: 15px 0;
        }
        
        #stepDisplay {
            text-align: center;
            margin: 5px 0;
            font-weight: bold;
        }
        
        .gradient-bar {
            height: 20px;
            background: linear-gradient(to right, #000 0%, #0f0 100%);
            border-radius: 3px;
            margin: 5px 0;
            position: relative;
        }
        
        .gradient-value {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 2px;
            background: white;
            transition: left 0.3s ease;
        }
        
        .experiment-item {
            background: #333;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 10px;
            margin: 5px 0;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .experiment-item:hover {
            background: #444;
        }
        
        .experiment-item.selected {
            background: #E85A00;  /* Darker orange */
            border-color: #2196F3;
        }
        
        .experiment-label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .experiment-details {
            font-size: 11px;
            color: #ccc;
        }
        
        #experimentList {
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .episode-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .episode-selector select {
            flex: 1;
            padding: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
        }
        
        #analytics {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 320px;
            height: 250px;
            background: rgba(20, 20, 20, 0.9);
            border-radius: 8px;
            border: 1px solid rgba(255, 107, 0, 0.3);
            padding: 15px;
            display: none;
            overflow: hidden;
        }
        
        .analytics-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .analytics-tab {
            padding: 5px 15px;
            background: #333;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .analytics-tab.active {
            background: #FF6B00;  /* Aperture orange */
        }
        
        .analytics-content {
            height: calc(100% - 40px);
            position: relative;
        }
        
        .chart-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
        }
        
        .chart-container.active {
            display: block;
        }
        
        #toggleAnalytics {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 5px 10px;
            background: #FF6B00;  /* Aperture orange */
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="loadingOverlay">Loading experiments...</div>
    
    <div id="info">
        <h3>Grid World Trajectory</h3>
        <div><span class="label">Grid Size:</span> <span id="gridSize">-</span></div>
        <div><span class="label">Episode:</span> <span id="episodeId">-</span></div>
        <div><span class="label">Total Steps:</span> <span id="totalSteps">-</span></div>
        <div><span class="label">Agent Position:</span> <span id="agentPos">-</span></div>
        <div><span class="label">Rewards Collected:</span> <span id="rewardsCollected">0</span></div>
        <div><span class="label">Cumulative Reward:</span> <span id="cumulativeReward">0</span></div>
        <div><span class="label">Coverage:</span> <span id="coverage">-</span></div>
        <div><span class="label">Seed:</span> <span id="seed">-</span></div>
        <br>
        <div class="label">Gradient Signal:</div>
        <div class="gradient-bar">
            <div class="gradient-value" id="gradientIndicator"></div>
        </div>
        <div id="gradientValue" style="text-align: center;">0.000</div>
        <br>
        <div class="label">Controls: Left click + drag to rotate, right click + drag to pan, scroll to zoom</div>
    </div>
    
    <button id="toggleAnalytics" onclick="toggleAnalytics()">ðŸ“Š Toggle Analytics</button>
    
    <div id="analytics">
        <div class="analytics-tabs">
            <button class="analytics-tab active" onclick="switchAnalyticsTab('rewards')">Reward Stats</button>
            <button class="analytics-tab" onclick="switchAnalyticsTab('timing')">Timing Analysis</button>
            <button class="analytics-tab" onclick="switchAnalyticsTab('network')">Network Dynamics</button>
        </div>
        <div class="analytics-content">
            <div id="rewardsChart" class="chart-container active">
                <canvas id="rewardsCanvas"></canvas>
            </div>
            <div id="timingChart" class="chart-container">
                <canvas id="timingCanvas"></canvas>
            </div>
            <div id="networkChart" class="chart-container">
                <canvas id="networkCanvas"></canvas>
            </div>
        </div>
    </div>
    
    <div id="controls">
        <h3>Experiment Selection</h3>
        <button onclick="refreshExperiments()">ðŸ”„ Refresh Experiments</button>
        
        <div style="margin: 10px 0;">
            <label class="label">Model Type:</label>
            <select id="modelSelect" onchange="selectModel()" style="width: 100%; padding: 5px; background: #333; color: white; border: 1px solid #555;">
                <option value="">Select a model...</option>
            </select>
        </div>
        
        <div id="runSelection" style="display: none;">
            <label class="label">Run:</label>
            <div id="experimentList">
                <div style="text-align: center; color: #666;">Select a model first</div>
            </div>
            
            <div class="episode-selector" id="episodeSelector" style="display: none;">
                <label class="label">Episode:</label>
                <select id="episodeSelect"></select>
                <button onclick="loadSelectedEpisode()">Load</button>
            </div>
        </div>
        
        <hr style="border-color: #444; margin: 15px 0;">
        
        <h3>Playback Controls</h3>
        <div id="stepDisplay">Step: 0 / 0</div>
        <input type="range" id="timeline" min="0" max="0" value="0" step="1">
        
        <div class="play-controls">
            <button id="playBtn" onclick="togglePlay()">â–¶ Play</button>
            <button onclick="resetTrajectory()">âŸ² Reset</button>
        </div>
        
        <label class="label">Playback Speed:</label>
        <input type="range" id="playSpeed" min="0.1" max="5" step="0.1" value="1">
        <div id="speedDisplay" style="text-align: center;">1.0x</div>
        
        <hr style="border-color: #444; margin: 15px 0;">
        
        <h3>Visual Options</h3>
        <button onclick="toggleTrail()">Toggle Trail</button>
        <button onclick="toggleGridLines()">Toggle Grid Lines</button>
        <button onclick="toggleRewardGlow()">Toggle Reward Glow</button>
        <button onclick="resetCamera()">Reset Camera</button>
        
        <br>
        <label class="label">
            <input type="checkbox" id="autoRotate" onchange="toggleAutoRotate()"> Auto Rotate
        </label>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Global variables
        let scene, camera, renderer, controls;
        let gridWorld, agent, rewards = [];
        let gridLines, trail, trailPositions = [];
        let animationId;
        let trajectoryData = null;
        let currentStep = 0;
        let isPlaying = false;
        let playInterval = null;
        let showTrail = true;
        let rewardGlows = [];
        let experimentsByModel = {};
        let selectedExperiment = null;
        let agentTargetPosition = new THREE.Vector3();
        let agentPreviousPosition = new THREE.Vector3();
        let agentTargetRotation = 0;
        let collectedRewardAnimations = [];
        
        // Analytics variables
        let rewardsChart = null;
        let timingChart = null;
        let networkChart = null;
        let analyticsData = {
            steps: [],
            cumulativeRewards: [],
            rewardTimestamps: [],
            timeBetweenRewards: [],
            gradientValues: [],
            neuralActivity: []
        };
        
        // Configuration
        let CONFIG = {
            gridSize: 10,
            cellSize: 1,
            wallHeight: 3,
            agentSize: 0.6,
            rewardSize: 0.3,
            agentColor: 0xF5F5F5,  // Clean white
            agentCoreColor: 0xFF6B00,  // Aperture orange
            rewardColor: 0x00A8E8,  // Aperture blue
            rewardGlowColor: 0x00D4FF,  // Bright blue glow
            collectedRewardColor: 0x333333,  // Dark gray
            floorColor: 0xFFFFFF,   // White floor
            wallColor: 0xF0F0F0,    // Clean white walls
            gridLineColor: 0x808080, // Gray grid lines
            trailColor: 0xFF6B00,   // Orange trail
            trailOpacity: 0.6
        };
        
        // Initialize the scene
        function init() {
            const container = document.getElementById('container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xF0F0F0);  // Soft white
            
            // Camera
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 500);
            camera.position.set(15, 12, 15);
            camera.lookAt(5, 0, 5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(5, 0, 5);
            controls.update();
            
            // Lights
            setupLights();
            
            // Window resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Timeline handler
            const timeline = document.getElementById('timeline');
            timeline.addEventListener('input', (e) => {
                currentStep = parseInt(e.target.value);
                updateVisualization();
            });
            
            // Speed control
            const speedSlider = document.getElementById('playSpeed');
            speedSlider.addEventListener('input', (e) => {
                document.getElementById('speedDisplay').textContent = e.target.value + 'x';
                updatePlaybackSpeed();
            });
            
            // Start animation loop
            animate();
            
            // Load experiments
            refreshExperiments();
        }
        
        async function refreshExperiments() {
            const modelSelect = document.getElementById('modelSelect');
            modelSelect.innerHTML = '<option value="">Loading models...</option>';
            document.getElementById('runSelection').style.display = 'none';
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingOverlay').textContent = 'Loading experiments...';
            
            try {
                const response = await fetch('/api/experiments');
                const data = await response.json();
                experimentsByModel = data.models;
                
                document.getElementById('loadingOverlay').style.display = 'none';
                
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                Object.keys(experimentsByModel).sort().forEach(modelName => {
                    const option = document.createElement('option');
                    option.value = modelName;
                    option.textContent = `${modelName} (${experimentsByModel[modelName].length} runs)`;
                    modelSelect.appendChild(option);
                });
                
                if (data.model_count === 0) {
                    modelSelect.innerHTML = '<option value="">No models found</option>';
                } else {
                    // Auto-load the latest model's latest run
                    autoLoadLatestRun(experimentsByModel);
                }
            } catch (error) {
                console.error('Error loading experiments:', error);
                modelSelect.innerHTML = '<option value="">Error loading models</option>';
                document.getElementById('loadingOverlay').style.display = 'none';
            }
        }
        
        async function autoLoadLatestRun(models) {
            // Find the latest model (highest phase number)
            const modelNames = Object.keys(models).sort();
            const latestModel = modelNames[modelNames.length - 1];
            
            if (!latestModel) return;
            
            // Set the model selector
            document.getElementById('modelSelect').value = latestModel;
            selectModel();
            
            // Wait a bit for the experiment list to populate
            setTimeout(() => {
                // Find the latest run (assuming they're sorted by timestamp)
                const experiments = experimentsByModel[latestModel];
                if (experiments && experiments.length > 0) {
                    // Get the latest experiment (last in the list)
                    const latestExp = experiments[experiments.length - 1];
                    
                    // Select and load it
                    selectedExperiment = latestExp;
                    
                    // Find and click the experiment div
                    const expDivs = document.querySelectorAll('#experimentList > div');
                    if (expDivs.length > 0) {
                        const lastExpDiv = expDivs[expDivs.length - 1];
                        lastExpDiv.click(); // This will trigger selectExperiment
                        
                        // Load the first episode after a short delay
                        setTimeout(() => {
                            if (document.getElementById('episodeSelect').options.length > 1) {
                                document.getElementById('episodeSelect').selectedIndex = 1;
                                loadEpisode();
                            }
                        }, 100);
                    }
                }
            }, 100);
        }
        
        window.selectModel = function() {
            const modelName = document.getElementById('modelSelect').value;
            
            if (!modelName) {
                document.getElementById('runSelection').style.display = 'none';
                return;
            }
            
            document.getElementById('runSelection').style.display = 'block';
            displayExperiments(modelName);
        };
        
        function displayExperiments(modelName) {
            const listDiv = document.getElementById('experimentList');
            listDiv.innerHTML = '';
            
            const modelExperiments = experimentsByModel[modelName] || [];
            
            if (modelExperiments.length === 0) {
                listDiv.innerHTML = '<div style="text-align: center; color: #666;">No runs found</div>';
                return;
            }
            
            modelExperiments.forEach((exp, index) => {
                const item = document.createElement('div');
                item.className = 'experiment-item';
                item.dataset.model = modelName;
                item.dataset.index = index;
                
                const label = document.createElement('div');
                label.className = 'experiment-label';
                label.textContent = exp.label;
                
                const details = document.createElement('div');
                details.className = 'experiment-details';
                
                const episodes = exp.episodes.length;
                const timestamp = new Date(exp.timestamp * 1000).toLocaleString();
                details.innerHTML = `
                    Episodes: ${episodes}<br>
                    Path: ${exp.directory}<br>
                    Time: ${timestamp}
                `;
                
                item.appendChild(label);
                item.appendChild(details);
                
                item.onclick = () => selectExperiment(modelName, index);
                
                listDiv.appendChild(item);
            });
        }
        
        function selectExperiment(modelName, index) {
            selectedExperiment = experimentsByModel[modelName][index];
            
            document.querySelectorAll('.experiment-item').forEach(item => item.classList.remove('selected'));
            document.querySelector(`[data-model="${modelName}"][data-index="${index}"]`).classList.add('selected');
            
            const episodeSelector = document.getElementById('episodeSelector');
            const episodeSelect = document.getElementById('episodeSelect');
            
            episodeSelector.style.display = 'flex';
            episodeSelect.innerHTML = '';
            
            selectedExperiment.episodes.forEach(ep => {
                const option = document.createElement('option');
                option.value = ep;
                option.textContent = `Episode ${ep}`;
                episodeSelect.appendChild(option);
            });
        }
        
        window.loadSelectedEpisode = async function() {
            if (!selectedExperiment) return;
            
            const episodeId = parseInt(document.getElementById('episodeSelect').value);
            
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingOverlay').textContent = 'Loading episode data...';
            
            try {
                const response = await fetch(`/api/trajectory?path=${encodeURIComponent(selectedExperiment.path)}&episode=${episodeId}`);
                trajectoryData = await response.json();
                
                if (trajectoryData.error) {
                    throw new Error(trajectoryData.message);
                }

                setupVisualization();
                document.getElementById('loadingOverlay').style.display = 'none';
            } catch (error) {
                console.error('Error loading episode:', error);
                document.getElementById('loadingOverlay').textContent = `Error: ${error.message}`;
            }
        };
        
        function setupLights() {
            // Soft ambient light for even illumination
            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.8);
            scene.add(ambientLight);
            
            // Subtle directional light from above
            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.4);
            directionalLight.position.set(5, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -15;
            directionalLight.shadow.camera.right = 15;
            directionalLight.shadow.camera.top = 15;
            directionalLight.shadow.camera.bottom = -15;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.bias = -0.001;
            scene.add(directionalLight);
            
            // Very subtle point light for agent glow
            const agentLight = new THREE.PointLight(CONFIG.agentCoreColor, 0.3, 3);
            agentLight.position.set(5, 1, 5);
            scene.add(agentLight);
        }
        
        function createGridWorld(gridSize) {
            // Remove existing world
            if (gridWorld) {
                scene.remove(gridWorld);
            }
            
            CONFIG.gridSize = gridSize;
            gridWorld = new THREE.Group();
            
            // Floor
            const floorGeometry = new THREE.BoxGeometry(
                CONFIG.gridSize * CONFIG.cellSize,
                0.1,
                CONFIG.gridSize * CONFIG.cellSize
            );
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: CONFIG.floorColor,
                specular: 0x404040,  // Much less reflective
                shininess: 10        // Matte finish
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.set(CONFIG.gridSize / 2, -0.05, CONFIG.gridSize / 2);
            floor.receiveShadow = true;
            gridWorld.add(floor);
            
            // Grid lines
            createGridLines();
            
            // Add walls
            createWalls();
            
            scene.add(gridWorld);
            
            // Update camera for grid size
            controls.target.set(CONFIG.gridSize / 2, 0, CONFIG.gridSize / 2);
            
            // Adjust camera distance based on grid size
            const cameraDistance = CONFIG.gridSize > 20 ? CONFIG.gridSize * 1.2 : CONFIG.gridSize * 1.5;
            const cameraHeight = CONFIG.gridSize > 20 ? CONFIG.gridSize * 0.8 : CONFIG.gridSize * 1.2;
            
            camera.position.set(cameraDistance, cameraHeight, cameraDistance);
            camera.far = CONFIG.gridSize * 3;
            camera.updateProjectionMatrix();
            
            // Update fog for larger grids
            if (CONFIG.gridSize > 20) {
                scene.fog = new THREE.Fog(0x202020, CONFIG.gridSize * 0.5, CONFIG.gridSize * 2);
            } else {
                scene.fog = new THREE.Fog(0x202020, 20, 60);
            }
            
            controls.update();
        }
        
        function createGridLines() {
            gridLines = new THREE.Group();
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: CONFIG.gridLineColor,
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });
            
            // For large grids, reduce line density
            const step = CONFIG.gridSize > 20 ? 5 : 1;
            const lineCount = Math.floor(CONFIG.gridSize / step) + 1;
            
            // Create grid lines with reduced density for large grids
            for (let i = 0; i < lineCount; i++) {
                const pos = i * step;
                
                // Horizontal lines
                const hGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0.01, pos),
                    new THREE.Vector3(CONFIG.gridSize, 0.01, pos)
                ]);
                const hLine = new THREE.Line(hGeometry, lineMaterial);
                gridLines.add(hLine);
                
                // Vertical lines
                const vGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(pos, 0.01, 0),
                    new THREE.Vector3(pos, 0.01, CONFIG.gridSize)
                ]);
                const vLine = new THREE.Line(vGeometry, lineMaterial);
                gridLines.add(vLine);
            }
            
            // Add edge lines if needed
            if (CONFIG.gridSize % step !== 0) {
                // Final horizontal line
                const hGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0.01, CONFIG.gridSize),
                    new THREE.Vector3(CONFIG.gridSize, 0.01, CONFIG.gridSize)
                ]);
                gridLines.add(new THREE.Line(hGeometry, lineMaterial));
                
                // Final vertical line
                const vGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(CONFIG.gridSize, 0.01, 0),
                    new THREE.Vector3(CONFIG.gridSize, 0.01, CONFIG.gridSize)
                ]);
                gridLines.add(new THREE.Line(vGeometry, lineMaterial));
            }
            
            gridWorld.add(gridLines);
        }
        
        function createWalls() {
            // Create platform sides (walls underneath)
            const platformMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x808080, // Gray platform sides
                specular: 0x404040,
                shininess: 30
            });
            
            const platformDepth = 2; // Depth of platform below floor
            const wallThickness = 0.3;
            
            // North side
            const northSide = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.gridSize * CONFIG.cellSize + wallThickness * 2, platformDepth, wallThickness),
                platformMaterial
            );
            northSide.position.set(CONFIG.gridSize / 2, -platformDepth / 2, -wallThickness / 2);
            northSide.castShadow = true;
            northSide.receiveShadow = true;
            gridWorld.add(northSide);
            
            // South side
            const southSide = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.gridSize * CONFIG.cellSize + wallThickness * 2, platformDepth, wallThickness),
                platformMaterial
            );
            southSide.position.set(CONFIG.gridSize / 2, -platformDepth / 2, CONFIG.gridSize + wallThickness / 2);
            southSide.castShadow = true;
            southSide.receiveShadow = true;
            gridWorld.add(southSide);
            
            // East side
            const eastSide = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, platformDepth, CONFIG.gridSize * CONFIG.cellSize + wallThickness * 2),
                platformMaterial
            );
            eastSide.position.set(CONFIG.gridSize + wallThickness / 2, -platformDepth / 2, CONFIG.gridSize / 2);
            eastSide.castShadow = true;
            eastSide.receiveShadow = true;
            gridWorld.add(eastSide);
            
            // West side
            const westSide = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, platformDepth, CONFIG.gridSize * CONFIG.cellSize + wallThickness * 2),
                platformMaterial
            );
            westSide.position.set(-wallThickness / 2, -platformDepth / 2, CONFIG.gridSize / 2);
            westSide.castShadow = true;
            westSide.receiveShadow = true;
            gridWorld.add(westSide);
            
            // Bottom of platform
            const bottomGeometry = new THREE.BoxGeometry(
                CONFIG.gridSize * CONFIG.cellSize + wallThickness * 2,
                0.1,
                CONFIG.gridSize * CONFIG.cellSize + wallThickness * 2
            );
            const bottom = new THREE.Mesh(bottomGeometry, platformMaterial);
            bottom.position.set(CONFIG.gridSize / 2, -platformDepth, CONFIG.gridSize / 2);
            bottom.receiveShadow = true;
            gridWorld.add(bottom);
        }
        
        function createAgent(position = [5, 0.3, 5]) {
            if (agent) {
                scene.remove(agent);
            }
            
            // Create agent group
            agent = new THREE.Group();
            
            // Create rounded box body (bright orange)
            const roundedBoxGeometry = createRoundedBoxGeometry(CONFIG.agentSize, CONFIG.agentSize, CONFIG.agentSize, 0.1, 2);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: CONFIG.agentCoreColor, // Bright orange
                emissive: CONFIG.agentCoreColor,
                emissiveIntensity: 0.2,
                specular: 0xFFFFFF,
                shininess: 100
            });
            const body = new THREE.Mesh(roundedBoxGeometry, bodyMaterial);
            body.castShadow = true;
            agent.add(body);
            
            // Add eyes
            const eyeGeometry = new THREE.SphereGeometry(CONFIG.agentSize * 0.08, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                specular: 0xFFFFFF,
                shininess: 100
            });
            
            // Left eye
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-CONFIG.agentSize * 0.2, CONFIG.agentSize * 0.15, CONFIG.agentSize * 0.51);
            agent.add(leftEye);
            
            // Right eye
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(CONFIG.agentSize * 0.2, CONFIG.agentSize * 0.15, CONFIG.agentSize * 0.51);
            agent.add(rightEye);
            
            agent.position.set(...position);
            scene.add(agent);
        }
        
        // Helper function to create rounded box geometry
        function createCollectionAnimation(reward, index) {
            const animation = {
                reward: reward,
                glow: rewardGlows[index],
                startTime: Date.now(),
                duration: 800,
                startScale: 1,
                endScale: 2,
                startOpacity: reward.material.opacity,
                particles: []
            };
            
            // Create particle burst
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: CONFIG.rewardGlowColor,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(reward.position);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        Math.random() * 0.2 + 0.1,
                        (Math.random() - 0.5) * 0.1
                    )
                };
                scene.add(particle);
                animation.particles.push(particle);
            }
            
            collectedRewardAnimations.push(animation);
        }
        
        function createRoundedBoxGeometry(width, height, depth, radius, smoothness) {
            const shape = new THREE.Shape();
            const eps = 0.00001;
            const radius0 = radius - eps;
            shape.absarc(radius0, radius0, radius0, -Math.PI / 2, -Math.PI, true);
            shape.absarc(radius0, height - radius * 2, radius0, Math.PI, Math.PI / 2, true);
            shape.absarc(width - radius * 2, height - radius * 2, radius0, Math.PI / 2, 0, true);
            shape.absarc(width - radius * 2, radius0, radius0, 0, -Math.PI / 2, true);
            
            const extrudeSettings = {
                depth: depth - radius * 2,
                bevelEnabled: true,
                bevelSegments: smoothness * 2,
                steps: 1,
                bevelSize: radius,
                bevelThickness: radius,
                curveSegments: smoothness
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center();
            
            return geometry;
        }
        
        function createRewards(positions) {
            // Clear existing rewards and glows
            rewards.forEach(reward => scene.remove(reward));
            rewards = [];
            rewardGlows.forEach(glow => scene.remove(glow));
            rewardGlows = [];
            
            // Reduce sphere complexity for large grids
            const segments = CONFIG.gridSize > 20 ? 8 : 16;
            
            // Create new rewards as energy orbs
            positions.forEach((pos, index) => {
                const geometry = new THREE.SphereGeometry(CONFIG.rewardSize / 2, segments, segments);
                const material = new THREE.MeshPhongMaterial({ 
                    color: CONFIG.rewardColor,
                    emissive: CONFIG.rewardColor,
                    emissiveIntensity: 0.5,
                    specular: 0xFFFFFF,
                    shininess: 200,
                    transparent: true,
                    opacity: 0.9
                });
                const reward = new THREE.Mesh(geometry, material);
                reward.position.set(pos[0] + 0.5, CONFIG.rewardSize / 2 + 0.3, pos[1] + 0.5);
                reward.castShadow = CONFIG.gridSize <= 20; // Disable shadows for large grids
                reward.userData = { collected: false, originalY: CONFIG.rewardSize / 2 + 0.3, index: index };
                rewards.push(reward);
                scene.add(reward);
                
                // Add glow effect
                if (CONFIG.gridSize <= 20) {
                    const glowGeometry = new THREE.SphereGeometry(CONFIG.rewardSize * 0.8, 8, 8);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: CONFIG.rewardGlowColor,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.position.copy(reward.position);
                    rewardGlows.push(glow);
                    scene.add(glow);
                }
            });
        }
        
        function createTrail() {
            if (trail) {
                scene.remove(trail);
            }
            
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.LineBasicMaterial({
                color: CONFIG.trailColor,
                transparent: true,
                opacity: CONFIG.trailOpacity,
                linewidth: 2
            });
            
            trail = new THREE.LineSegments(geometry, material);
            scene.add(trail);
        }
        
        function updateTrail() {
            if (!trail || !showTrail || !trajectoryData) return;
            
            const positions = [];
            const indices = [];
            let currentSegmentStart = 0;
            
            for (let i = 0; i <= currentStep && i < trajectoryData.trajectory.length; i++) {
                const step = trajectoryData.trajectory[i];
                
                // Check for toroidal wrap
                if (i > 0) {
                    const prevStep = trajectoryData.trajectory[i - 1];
                    const dx = Math.abs(step.agentPos[0] - prevStep.agentPos[0]);
                    const dy = Math.abs(step.agentPos[1] - prevStep.agentPos[1]);
                    
                    // If movement is more than half the grid size, it's a wrap
                    if (dx > CONFIG.gridSize / 2 || dy > CONFIG.gridSize / 2) {
                        // Create line segment for previous continuous path
                        for (let j = currentSegmentStart; j < positions.length / 3 - 1; j++) {
                            indices.push(j, j + 1);
                        }
                        currentSegmentStart = positions.length / 3;
                    }
                }
                
                positions.push(
                    step.agentPos[0] + 0.5,
                    0.1,
                    step.agentPos[1] + 0.5
                );
            }
            
            // Add final segment
            for (let j = currentSegmentStart; j < positions.length / 3 - 1; j++) {
                indices.push(j, j + 1);
            }
            
            trail.geometry.setAttribute('position', 
                new THREE.Float32BufferAttribute(positions, 3)
            );
            trail.geometry.setIndex(indices);
        }
        
        function setupVisualization() {
            if (!trajectoryData) return;
            
            // Update metadata display
            const meta = trajectoryData.metadata;
            document.getElementById('gridSize').textContent = `${meta.gridSize}x${meta.gridSize}`;
            document.getElementById('episodeId').textContent = meta.episodeId || '0';
            document.getElementById('totalSteps').textContent = meta.totalSteps;
            document.getElementById('coverage').textContent = meta.coverage ? `${(meta.coverage * 100).toFixed(1)}%` : 'N/A';
            document.getElementById('seed').textContent = meta.seed || 'N/A';
            
            // Create world
            createGridWorld(meta.gridSize);
            
            // Create rewards
            createRewards(trajectoryData.world.rewardPositions);
            
            // Create agent at initial position
            const initialPos = trajectoryData.trajectory[0].agentPos;
            createAgent([initialPos[0] + 0.5, CONFIG.agentSize / 2, initialPos[1] + 0.5]);
            
            // Initialize agent position tracking
            agentTargetPosition.set(initialPos[0] + 0.5, CONFIG.agentSize / 2, initialPos[1] + 0.5);
            agentPreviousPosition.copy(agentTargetPosition);
            agentTargetRotation = 0;
            
            // Create trail
            createTrail();
            
            // Setup timeline
            const timeline = document.getElementById('timeline');
            timeline.max = meta.totalSteps;
            timeline.value = 0;
            currentStep = 0;
            
            // Process analytics data
            processAnalyticsData();
            
            // Update display
            updateVisualization();
        }
        
        function updateVisualization() {
            if (!trajectoryData || currentStep >= trajectoryData.trajectory.length) return;
            
            const stepData = trajectoryData.trajectory[currentStep];
            
            // Update agent target position for smooth movement
            if (agent) {
                // Store previous position for direction calculation
                agentPreviousPosition.copy(agentTargetPosition);
                
                agentTargetPosition.set(
                    stepData.agentPos[0] + 0.5,
                    agent.position.y,
                    stepData.agentPos[1] + 0.5
                );
                
                // Calculate direction based on movement
                const dx = agentTargetPosition.x - agentPreviousPosition.x;
                const dz = agentTargetPosition.z - agentPreviousPosition.z;
                
                // Only update rotation if there's actual movement
                if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
                    // Calculate angle (0 = facing +Z, PI/2 = facing +X, etc.)
                    agentTargetRotation = Math.atan2(dx, dz);
                }
            }
            
            // Update rewards collected status with animation
            if (stepData.rewardCollected) {
                stepData.rewardCollected.forEach((collected, index) => {
                    if (rewards[index] && collected && !rewards[index].userData.collected) {
                        // Trigger collection animation for newly collected rewards
                        createCollectionAnimation(rewards[index], index);
                        rewards[index].userData.collected = true;
                    }
                });
            }
            
            // Update trail
            updateTrail();
            
            // Update info display
            document.getElementById('agentPos').textContent = 
                `(${stepData.agentPos[0]}, ${stepData.agentPos[1]})`;
            
            const collected = stepData.rewardCollected ? 
                stepData.rewardCollected.filter(r => r).length : 0;
            document.getElementById('rewardsCollected').textContent = 
                `${collected}/${trajectoryData.metadata.nRewards}`;
            
            document.getElementById('cumulativeReward').textContent = 
                stepData.cumulativeReward ? stepData.cumulativeReward.toFixed(1) : '0';
            
            // Update gradient display
            const gradient = stepData.observation || 0;
            document.getElementById('gradientValue').textContent = gradient.toFixed(3);
            document.getElementById('gradientIndicator').style.left = (gradient * 100) + '%';
            
            // Update step display
            document.getElementById('stepDisplay').textContent = 
                `Step: ${currentStep} / ${trajectoryData.metadata.totalSteps}`;
                
            // Update analytics if visible
            const analyticsPanel = document.getElementById('analytics');
            if (analyticsPanel.style.display === 'block') {
                updateAnalyticsCharts();
            }
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Smooth agent movement
            if (agent && agentTargetPosition) {
                agent.position.lerp(agentTargetPosition, 0.15);
                
                // Smooth rotation
                const currentRotation = agent.rotation.y;
                const rotationDiff = agentTargetRotation - currentRotation;
                
                // Handle rotation wrap-around
                let shortestDiff = rotationDiff;
                if (Math.abs(rotationDiff) > Math.PI) {
                    shortestDiff = rotationDiff - Math.sign(rotationDiff) * 2 * Math.PI;
                }
                
                agent.rotation.y += shortestDiff * 0.2; // Smooth rotation lerp
                
                // Update agent light position
                const agentLight = scene.children.find(child => child.isPointLight && child.color.getHex() === CONFIG.agentCoreColor);
                if (agentLight) {
                    agentLight.position.copy(agent.position);
                    agentLight.position.y += 1;
                }
                
                // Add subtle bounce to agent
                const bounce = Math.sin(Date.now() * 0.003) * 0.02;
                agent.position.y = agentTargetPosition.y + bounce;
            }
            
            // Animate rewards (floating effect) - reduced for large grids
            const time = Date.now() * 0.001;
            if (CONFIG.gridSize <= 20) {
                rewards.forEach((reward, index) => {
                    if (!reward.userData.collected) {
                        reward.position.y = reward.userData.originalY + Math.sin(time * 2 + index) * 0.1;
                        reward.rotation.y = time * 0.5;
                        
                        if (rewardGlows[index]) {
                            rewardGlows[index].position.y = reward.position.y;
                            const scale = 1 + Math.sin(time * 3 + index) * 0.1;
                            rewardGlows[index].scale.set(scale, scale, scale);
                        }
                    }
                });
            } else {
                // Simplified animation for large grids
                rewards.forEach((reward, index) => {
                    if (!reward.userData.collected) {
                        reward.rotation.y = time * 0.5;
                    }
                });
            }
            
            // Animate agent (subtle pulsing)
            if (agent) {
                const scale = 1 + Math.sin(time * 3) * 0.05;
                agent.scale.set(scale, scale, scale);
            }
            
            // Auto-rotate if enabled
            if (document.getElementById('autoRotate').checked) {
                gridWorld.rotation.y += 0.002;
            }
            
            // Update collection animations
            collectedRewardAnimations = collectedRewardAnimations.filter(anim => {
                const elapsed = Date.now() - anim.startTime;
                const progress = Math.min(elapsed / anim.duration, 1);
                
                if (progress < 1) {
                    // Scale and fade reward
                    const scale = anim.startScale + (anim.endScale - anim.startScale) * progress;
                    anim.reward.scale.setScalar(scale);
                    anim.reward.material.opacity = anim.startOpacity * (1 - progress);
                    
                    if (anim.glow) {
                        anim.glow.scale.setScalar(scale * 1.5);
                        anim.glow.material.opacity = 0.3 * (1 - progress);
                    }
                    
                    // Update particles
                    anim.particles.forEach(particle => {
                        particle.position.add(particle.userData.velocity);
                        particle.userData.velocity.y -= 0.005; // gravity
                        particle.material.opacity = 0.8 * (1 - progress);
                        particle.scale.setScalar(1 - progress * 0.5);
                    });
                    
                    return true;
                } else {
                    // Animation complete - cleanup
                    anim.reward.visible = false;
                    if (anim.glow) anim.glow.visible = false;
                    anim.particles.forEach(particle => scene.remove(particle));
                    return false;
                }
            });
            
            // Render
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Control functions
        window.togglePlay = function() {
            isPlaying = !isPlaying;
            const playBtn = document.getElementById('playBtn');
            
            if (isPlaying) {
                playBtn.textContent = 'â¸ Pause';
                startPlayback();
            } else {
                playBtn.textContent = 'â–¶ Play';
                stopPlayback();
            }
        };
        
        function startPlayback() {
            if (!trajectoryData) return;
            
            const speed = parseFloat(document.getElementById('playSpeed').value);
            const interval = 100 / speed; // Base interval 100ms
            
            playInterval = setInterval(() => {
                if (currentStep < trajectoryData.metadata.totalSteps) {
                    currentStep++;
                    document.getElementById('timeline').value = currentStep;
                    updateVisualization();
                } else {
                    togglePlay(); // Stop at end
                }
            }, interval);
        }
        
        function stopPlayback() {
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }
        
        // Update playback speed dynamically
        window.updatePlaybackSpeed = function() {
            if (isPlaying) {
                stopPlayback();
                startPlayback();
            }
        };
        
        window.resetTrajectory = function() {
            if (isPlaying) togglePlay();
            currentStep = 0;
            document.getElementById('timeline').value = 0;
            updateVisualization();
        };
        
        window.toggleTrail = function() {
            showTrail = !showTrail;
            if (trail) trail.visible = showTrail;
        };
        
        window.toggleGridLines = function() {
            if (gridLines) gridLines.visible = !gridLines.visible;
        };
        
        window.toggleRewardGlow = function() {
            rewardGlows.forEach(glow => {
                glow.visible = !glow.visible;
            });
        };
        
        window.resetCamera = function() {
            const cameraDistance = CONFIG.gridSize > 20 ? CONFIG.gridSize * 1.2 : CONFIG.gridSize * 1.5;
            const cameraHeight = CONFIG.gridSize > 20 ? CONFIG.gridSize * 0.8 : CONFIG.gridSize * 1.2;
            
            camera.position.set(cameraDistance, cameraHeight, cameraDistance);
            controls.target.set(CONFIG.gridSize / 2, 0, CONFIG.gridSize / 2);
            controls.update();
        };
        
        window.toggleAutoRotate = function() {
            if (!document.getElementById('autoRotate').checked && gridWorld) {
                gridWorld.rotation.y = 0;
            }
        };
        
        window.refreshExperiments = refreshExperiments;
        
        // Analytics functions
        function initializeAnalytics() {
            initializeRewardsChart();
            initializeTimingChart();
            initializeNetworkChart();
        }
        
        function initializeRewardsChart() {
            const ctx = document.getElementById('rewardsCanvas').getContext('2d');
            rewardsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Cumulative Rewards',
                        data: [],
                        borderColor: '#4CAF50',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        tension: 0.1
                    }, {
                        label: 'Gradient Signal',
                        data: [],
                        borderColor: '#2196F3',
                        backgroundColor: 'rgba(33, 150, 243, 0.1)',
                        tension: 0.1,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            labels: { color: 'white' }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Step', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Rewards', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Gradient', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });
        }
        
        function initializeTimingChart() {
            const ctx = document.getElementById('timingCanvas').getContext('2d');
            timingChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Time Between Rewards (steps)',
                        data: [],
                        backgroundColor: '#FF9800',
                        borderColor: '#F57C00',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: 'white' }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Reward #', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'Steps', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }
        
        function initializeNetworkChart() {
            const ctx = document.getElementById('networkCanvas').getContext('2d');
            networkChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Average Firing Rate (Hz)',
                        data: [],
                        borderColor: '#E91E63',
                        backgroundColor: 'rgba(233, 30, 99, 0.1)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: 'white' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const step = context.parsed.x;
                                    const data = trajectoryData?.trajectory[step];
                                    if (data?.neuralActivity) {
                                        const firingRate = data.neuralActivity.firingRateHz || 
                                            ((data.neuralActivity.spikeCount / 256) * 1000.0);
                                        return [
                                            `Firing Rate: ${firingRate.toFixed(1)} Hz`,
                                            `Spike Count: ${data.neuralActivity.spikeCount}`,
                                            `Mean Potential: ${data.neuralActivity.meanPotential.toFixed(1)} mV`,
                                            `Max Potential: ${data.neuralActivity.maxPotential.toFixed(1)} mV`
                                        ];
                                    }
                                    return `Firing Rate: ${(context.parsed.y * 10).toFixed(1)} Hz`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Step', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'Firing Rate (Hz)', color: 'white' },
                            ticks: { color: 'white' },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    }
                }
            });
        }
        
        function processAnalyticsData() {
            if (!trajectoryData) return;
            
            analyticsData = {
                steps: [],
                cumulativeRewards: [],
                rewardTimestamps: [],
                timeBetweenRewards: [],
                gradientValues: [],
                neuralActivity: []
            };
            
            let lastRewardStep = 0;
            let prevRewardsCollected = 0;
            
            trajectoryData.trajectory.forEach((step, index) => {
                analyticsData.steps.push(index);
                analyticsData.cumulativeRewards.push(step.cumulativeReward || 0);
                analyticsData.gradientValues.push(step.observation || 0);
                
                // Check for new rewards
                const currentRewardsCollected = step.rewardCollected ? 
                    step.rewardCollected.filter(r => r).length : 0;
                
                if (currentRewardsCollected > prevRewardsCollected) {
                    analyticsData.rewardTimestamps.push(index);
                    if (analyticsData.rewardTimestamps.length > 1) {
                        analyticsData.timeBetweenRewards.push(index - lastRewardStep);
                    }
                    lastRewardStep = index;
                    prevRewardsCollected = currentRewardsCollected;
                }
                
                // Extract neural activity data if available
                if (step.neuralActivity) {
                    // Use actual firing rate in Hz if available, otherwise calculate from spike count
                    let firingRate = 0;
                    if (step.neuralActivity.firingRateHz !== undefined) {
                        // Use pre-calculated firing rate, normalize to typical 0-10Hz range
                        firingRate = step.neuralActivity.firingRateHz / 10.0;
                    } else if (step.neuralActivity.spikeCount !== undefined) {
                        // Fallback: estimate from spike count (assuming 256 neurons, 1ms timestep)
                        firingRate = (step.neuralActivity.spikeCount / 256) * 1000.0 / 10.0;
                    }
                    analyticsData.neuralActivity.push(firingRate);
                } else {
                    // Fallback for episodes without neural data
                    analyticsData.neuralActivity.push(0);
                }
            });
        }
        
        function updateAnalyticsCharts() {
            if (!analyticsData.steps.length) return;
            
            // Update data up to current step
            const currentData = {
                steps: analyticsData.steps.slice(0, currentStep + 1),
                cumulativeRewards: analyticsData.cumulativeRewards.slice(0, currentStep + 1),
                gradientValues: analyticsData.gradientValues.slice(0, currentStep + 1),
                neuralActivity: analyticsData.neuralActivity.slice(0, currentStep + 1)
            };
            
            // Update rewards chart
            if (rewardsChart) {
                rewardsChart.data.labels = currentData.steps;
                rewardsChart.data.datasets[0].data = currentData.cumulativeRewards;
                rewardsChart.data.datasets[1].data = currentData.gradientValues;
                rewardsChart.update('none');
            }
            
            // Update timing chart
            if (timingChart && analyticsData.timeBetweenRewards.length > 0) {
                const rewardsUpToCurrent = analyticsData.rewardTimestamps.filter(t => t <= currentStep);
                const timingData = analyticsData.timeBetweenRewards.slice(0, rewardsUpToCurrent.length - 1);
                
                timingChart.data.labels = timingData.map((_, i) => `Reward ${i + 2}`);
                timingChart.data.datasets[0].data = timingData;
                timingChart.update('none');
            }
            
            // Update network chart
            if (networkChart) {
                networkChart.data.labels = currentData.steps;
                // Scale back to Hz for display (data is normalized to 0-1 range)
                const scaledData = currentData.neuralActivity.map(rate => rate * 10);
                networkChart.data.datasets[0].data = scaledData;
                networkChart.update('none');
            }
        }
        
        window.toggleAnalytics = function() {
            const analyticsPanel = document.getElementById('analytics');
            const toggleBtn = document.getElementById('toggleAnalytics');
            
            if (analyticsPanel.style.display === 'none' || !analyticsPanel.style.display) {
                analyticsPanel.style.display = 'block';
                toggleBtn.style.bottom = '270px';
                if (!rewardsChart) {
                    initializeAnalytics();
                }
                updateAnalyticsCharts();
            } else {
                analyticsPanel.style.display = 'none';
                toggleBtn.style.bottom = '10px';
            }
        };
        
        window.switchAnalyticsTab = function(tab) {
            // Update tab buttons
            document.querySelectorAll('.analytics-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update chart containers
            document.querySelectorAll('.chart-container').forEach(container => {
                container.classList.remove('active');
            });
            
            switch(tab) {
                case 'rewards':
                    document.getElementById('rewardsChart').classList.add('active');
                    break;
                case 'timing':
                    document.getElementById('timingChart').classList.add('active');
                    break;
                case 'network':
                    document.getElementById('networkChart').classList.add('active');
                    break;
            }
        };
        
        window.refreshExperiments = refreshExperiments;
        
        // Initialize on load
        init();
    </script>
</body>
</html>
